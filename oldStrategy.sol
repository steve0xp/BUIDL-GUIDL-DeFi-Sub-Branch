// SPDX-License-Identifier: AGPL-3.0
// Feel free to change the license, but this is what we use

pragma solidity ^0.8.12;
pragma experimental ABIEncoderV2;

// These are the core Yearn libraries
import {BaseStrategy, StrategyParams} from "@yearnvaults/contracts/BaseStrategy.sol";

import {Address} from "@openzeppelin/contracts/utils/Address.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // TUTORIAL
// import "./interfaces/Compound/ICToken.sol"; // TUTORIAL

// Import interfaces for many popular DeFi projects, or add your own!
//import "./interfaces/<protocol>/<Interface>.sol";

contract Strategy is BaseStrategy {
    using SafeERC20 for IERC20;
    using Address for address;

    constructor(address _vault) BaseStrategy(_vault) {
        want.approve(address(cDAI), type(uint256.max)); // TUTORIAL
        // You can set these parameters on deployment to whatever you want
        // maxReportDelay = 6300;
        // profitFactor = 100;
        // debtThreshold = 0;
    }

    // ******** OVERRIDE THESE METHODS FROM BASE CONTRACT ************

    /// @notice names the strategy
    /// @return name of the strategy
    /// @dev defined in implementation, called by constructor
    function name() external view override returns (string memory) {
        // Add your own name here, suggestion e.g. "StrategyCreamYFI"
        return "StrategyCompoundDAI"; // TUTORIAL
    }

    /// @notice 
    function estimatedTotalAssets() public view override returns (uint256) {
        // TODO: Build a more accurate estimate using the value of all positions in terms of `want`
        return want.balanceOf(address(this)) + cDAI.balanceOf(address(this)) * cDAI.exchangeRateStored() / 1e18; // TUTORIAL
    }

    /// @notice called when preparing return, accounting losses and gains from the last time harvest() has been called. 
    /// @param debtOutstanding - how much want token does the vault want right now. You're preparing the return of the DAI, liquidiating antying you can to get that amount back to the vault.
    /// @dev Part of Harvest "flow" - bot calls "harvest()", it calls this function && adjustPosition()
    /// NOTE all implementation is from the tutorial
    function prepareReturn(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        // TODO: Do stuff here to free up any returns back into `want`
        // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
        // NOTE: Should try to free up at least `_debtOutstanding` of underlying position

        // NOTE - TUTORIAL for all implementation code written up here.
        uint256 _totalAssets = estimatedTotalAssets();
        uint256 _totalDebt = vault.strategies(address(this)).totalDebt; // NOTE - interesting that there is a totalDebt property inside what looks like a strategies struct within vaults?

        if (_totalAssets >= _totalDebt) {
            _profit = _totalAssets - _totalDebt;
            _loss = 0;
        } else {
            _profit = 0;
            _loss = totalDebt - _totalAssets;
        }

        withdrawSome(_debtOutstanding + _profit); // TUTORIAL
        // _profit needs to be liquid in wantToken, and we'll try to liquidate as much of _debtOutstanding back to wantToken so we can pay it back to the vault. If we just say we have profit, the vault doesn't trust it, it needs to see it in wantToken so that's why we liquidate it. NOTE - this is good. this takes the conservative route of actually pulling the funds out into the vault vs "saying it's there and not doing it." It's just good accounting.

        uint256 _liquidWant = want.balanceOf(Address(this));

        // TODO: FROM TUTORIAL: need to better understand this logic. Am I missing something? This seems incorrect. 
        if (_liquidWant <= _profit) {
            _profit = _liquidWant;
            _debtPayment = 0;
        // enough to pay for all profit and _debtOutstanding (partial or full)
        } else {
            _debtPayment = Math.min(_liquidWant - _profit, _debtOutstanding);
        }
    }

    /// @notice investing excess want token into the strategy
    /// @dev Part of Harvest "flow" - bot calls "harvest()", it calls this function && prepareReturn()
    // solhint-disable-next-line no-empty-blocks
    function adjustPosition(uint256 _debtOutstanding) internal override {
        // TODO: Do something to invest excess `want` tokens (from the Vault) into your positions
        // NOTE: Try to adjust positions so that `_debtOutstanding` can be freed up on *next* harvest (not immediately)

        uint256 _daiBal = want.balanceOf(address(this));
        if (_daiBal > _debtOutstanding) {
            uint256 _excessDai = _daiBal - _debtOutstanding;
            uint256 _status = cDAI.mint(_excessDai);
            assert(_status == 0);
        }
    }

    /// @notice part of withdraw: liquidate as much as possible, if not enough then declare losses.
    /// @dev part of withdraw: user withdraws from vault, calling withdraw on the strategy which then calls this function 
    function liquidatePosition(uint256 _amountNeeded)
        internal
        override
        returns (uint256 _liquidatedAmount, uint256 _loss)
    {
        // TODO: Do stuff here to free up to `_amountNeeded` from all positions back into `want`
        // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount`
        // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded`
        uint256 _daiBal = want.balanceOf(address(this));

        if (_daiBal >= amountNeeded) {
            return (_amountNeeded, 0);
        }
        withdrawSome(_amountNeeded);
        _daiBal = want.balanceOf(address(this));

        if (_amountNeeded > _daiBal) {
            _liquidatedAmount = _daiBal;
            _loss = _amountNeeded - _daiBal;
        } else {
            _liquidatedAmount = _amountNeeded;
        }
    }

    /// @notice
    /// @dev 
    /// NOTE - implementation all part of tutorial
    function withdrawSome(uint256 _amountNeeded) internal {
        uint256 _cDaiToBurn = Math.min( _amountNeeded * 1e18 / cDAI.exchangeRateStored(), cDAI.balanceOf(address(this))); // TODO - look at this more
        
        uint256 _status = cDAI.redeem(_cDaiToBurn);
        assert(_status == 0);
    }

    /// @notice
    function liquidateAllPositions() internal override returns (uint256) {
        // TODO: Liquidate all positions and return the amount freed.
        uint256 _status = cDai.redeem(cDAI.balanceOf(address(this)));
        assert(_status ==0);
        return want.balanceOf(address(this));
    }

    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary
    /// @notice transfer any non-want tokens to a new strategy, if you change the strategy code and deploy a new one.
    /// @dev all they have is cDAI in the example.
    function prepareMigration(address _newStrategy) internal override {
        // TODO: Transfer any non-`want` tokens to the new strategy
        // NOTE: `migrate` will automatically forward all `want` in this strategy to the new one
        cDAI.transfer(_newStrategy, cDAI.balanceOf(address(this)));
    }

    // Override this to add all tokens/tokenized positions this contract manages
    // on a *persistent* basis (e.g. not just for swapping back to want ephemerally)
    // NOTE: Do *not* include `want`, already included in `sweep` below
    //
    // Example:
    //
    //    function protectedTokens() internal override view returns (address[] memory) {
    //      address[] memory protected = new address[](3);
    //      protected[0] = tokenA;
    //      protected[1] = tokenB;
    //      protected[2] = tokenC;
    //      return protected;
    //    }
    function protectedTokens()
        internal
        view
        override
        returns (address[] memory)
    // solhint-disable-next-line no-empty-blocks
    {

    }

    /**
     * @notice
     *  Provide an accurate conversion from `_amtInWei` (denominated in wei)
     *  to `want` (using the native decimal characteristics of `want`).
     * @dev
     *  Care must be taken when working with decimals to assure that the conversion
     *  is compatible. As an example:
     *
     *      given 1e17 wei (0.1 ETH) as input, and want is USDC (6 decimals),
     *      with USDC/ETH = 1800, this should give back 1800000000 (180 USDC)
     *
     * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`
     * @return The amount in `want` of `_amtInEth` converted to `want`
     **/
    function ethToWant(uint256 _amtInWei)
        public
        view
        virtual
        override
        returns (uint256)
    {
        // TODO create an accurate price oracle
        return _amtInWei;
    }
}
